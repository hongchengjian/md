# 数据结构

## 二叉树 VS 平衡二叉树AVL VS 跳跃表 VS 红黑树 VS B+ VS B-

二叉查找树Binary Search Tree/Binary Sort Tree：左子树的节点值比父亲节点小，而右子树的节点值比父亲节点大。手写二分查找算法。二分查找算法复杂度最好O(logn)，最差送你一串冰糖葫芦O(n)。

排序：归并(合并)分治法、In-place Sort、External Sort

平衡二叉树AVL：（1）左子树的节点值比父亲节点小，而右子树的节点值比父亲节点大。（2）每个节点的左子树和右子树的高度差至多等于1。

平衡二叉树解决二叉查找树退化成一串链表，保证不出现大量节点偏向于一边。 查找算法复杂度O(logn)。

由于平衡树要求每个节点的左子树和右子树的高度差至多等于1太严了，每次进行插入/删除节点时，都需通过**左旋**和**右旋**来进行调整再次成为一颗符合要求的平衡树。不适应频繁插入、删除场景。

什么是跳跃表？

什么是红黑树？（1）左子树的节点值比父亲节点小，而右子树的节点值比父亲节点大。（2）根节点是黑色。（3）每个叶节点都是黑色的空节点（NIL），叶节点不存数据。（4）任何相邻的节点都不能同时为红色，红色节点是被黑色节点隔开。**红黑树是一种不大严格的平衡树**。

红黑树一个node只存一对kv，B+树每个node存多对kv，其中第一个key有序，从左向右，一个node存多个kv的方式CPU cache命中率更高，高并发索引选B+树。**红黑树比平衡二叉树AVL适应频繁插入、删除**。

红黑树查找某个节点：O(logn)

红黑树 VS 哈希表不同场景的选择

什么是B+树（MySQL  InnoDB索引）？ https://en.wikipedia.org/wiki/B%2B_tree

根节点存索引节点，叶节点存数据节点。所有叶子节点形成有序链表，便于区间查询以及全结点遍历更快。

非叶子结点不存储Data，起目录作用。二叉树适合查找一个特定值O(log(N))，查找两个值之间的多个元素成本是O(N)，O(N)原因是必须查找树的每一个节点，判断它是否处于两个值之间（树的中序遍历）为解决二叉树查找两个值之间的多个元素成本是O(N)问题，引入B+树。B+树只有叶节点（最底层的节点）才保存数据，其他节点只在搜索中指引到正确节点。

![B+索引](../../../../../MD/img/B+%E7%B4%A2%E5%BC%95.png)



```css
要找40到100
(1)若40不存在则找40之后
(2)连接收集40后续节点，直到找到100
找到了 M 个后续节点，树总共有 N 个节点，找到指定节点的搜索成本是O(N)，找到指定节点后续节点的连接得到 M 个后续节点成本需M运算，一共花费M+log(N)，成本取决于M的大小。若增加或删除一行，
```

问题核心在于

```css
(1)B+树中的节点之间保持顺序
(2)尽可能降低B+树层数，否则 O(log(N))会变成 O(N)

说明：B+树需自我整理和自我平衡(使用太多索引不是个好主意，减慢了快速插入/更新/删除表中的一个行，数据库需以代价每索引 O(log(N)) 来更新表的索引)
```

什么是B树（MongoDB索引）？根结点和叶节点都存数据。

B树适合数据聚合。经常访问的数据离根节点很近（基于频率的搜索），越频繁query的结点越往根上走。

B+树是平衡二叉树吗？是AVL树。

跳跃表缺点耗内存、Redis经常有范围操作比如list ltrim可利用跳跃表里的双向链表，缓存cache locality不会比平衡树差。并发下红黑树插入和删除元素需做Rebalance操作，但它更适合查询。

## 二维阵列Array VS  Binary Sort Tree二叉树 VS Hash

Hash链接 锁表或者缓冲池  Hash查询仅耗费了 2 次运算，第1次计算哈希值，第2次在哈希桶中查找元素，挑战在于找到好的hash函数，算法复杂度是O(1)，让bucket中包含非常少的元素

```css
Hash表 VS 阵列
一个hash表可以只装载一半到内存，剩下的Bucket可以留硬盘，hash方便关键字搜索
阵列需连续内存空间，加载一个大表很难分配出足够的物理连续内存
```

# 算法

## In-place Algorithm

```
不创建新序列而是直接修改输入序列
```

## External Sorting

```
多处理器，多服务器，多线程运行
```

